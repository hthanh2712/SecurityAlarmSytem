\hypertarget{queue_8h_source}{}\doxysection{queue.\+h}
\label{queue_8h_source}\index{lib/Arduino\_FreeRTOS/src/queue.h@{lib/Arduino\_FreeRTOS/src/queue.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{ * FreeRTOS Kernel V10.4.3}}
\DoxyCodeLine{3 \textcolor{comment}{ * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.}}
\DoxyCodeLine{4 \textcolor{comment}{ *}}
\DoxyCodeLine{5 \textcolor{comment}{ * Permission is hereby granted, free of charge, to any person obtaining a copy of}}
\DoxyCodeLine{6 \textcolor{comment}{ * this software and associated documentation files (the "{}Software"{}), to deal in}}
\DoxyCodeLine{7 \textcolor{comment}{ * the Software without restriction, including without limitation the rights to}}
\DoxyCodeLine{8 \textcolor{comment}{ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of}}
\DoxyCodeLine{9 \textcolor{comment}{ * the Software, and to permit persons to whom the Software is furnished to do so,}}
\DoxyCodeLine{10 \textcolor{comment}{ * subject to the following conditions:}}
\DoxyCodeLine{11 \textcolor{comment}{ *}}
\DoxyCodeLine{12 \textcolor{comment}{ * The above copyright notice and this permission notice shall be included in all}}
\DoxyCodeLine{13 \textcolor{comment}{ * copies or substantial portions of the Software.}}
\DoxyCodeLine{14 \textcolor{comment}{ *}}
\DoxyCodeLine{15 \textcolor{comment}{ * THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}}
\DoxyCodeLine{16 \textcolor{comment}{ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS}}
\DoxyCodeLine{17 \textcolor{comment}{ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR}}
\DoxyCodeLine{18 \textcolor{comment}{ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER}}
\DoxyCodeLine{19 \textcolor{comment}{ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN}}
\DoxyCodeLine{20 \textcolor{comment}{ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}
\DoxyCodeLine{21 \textcolor{comment}{ *}}
\DoxyCodeLine{22 \textcolor{comment}{ * https://www.FreeRTOS.org}}
\DoxyCodeLine{23 \textcolor{comment}{ * https://github.com/FreeRTOS}}
\DoxyCodeLine{24 \textcolor{comment}{ *}}
\DoxyCodeLine{25 \textcolor{comment}{ */}}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{preprocessor}{\#ifndef QUEUE\_H}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#define QUEUE\_H}}
\DoxyCodeLine{30 }
\DoxyCodeLine{31 \textcolor{preprocessor}{\#ifndef INC\_ARDUINO\_FREERTOS\_H}}
\DoxyCodeLine{32 \textcolor{preprocessor}{    \#error "{}include Arduino\_FreeRTOS.h"{}} must appear in source files before "{}include queue.h"{}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{comment}{/* *INDENT-\/OFF* */}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{37     \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \{}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{39 \textcolor{comment}{/* *INDENT-\/ON* */}}
\DoxyCodeLine{40 }
\DoxyCodeLine{41 \textcolor{preprocessor}{\#include "{}task.h"{}}}
\DoxyCodeLine{42 }
\DoxyCodeLine{48 \textcolor{keyword}{struct }\mbox{\hyperlink{structQueueDef__t}{QueueDef\_t}};}
\DoxyCodeLine{49 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structQueueDef__t}{QueueDef\_t}} * \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}};}
\DoxyCodeLine{50 }
\DoxyCodeLine{56 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structQueueDef__t}{QueueDef\_t}} * \mbox{\hyperlink{structQueueDef__t}{QueueSetHandle\_t}};}
\DoxyCodeLine{57 }
\DoxyCodeLine{63 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structQueueDef__t}{QueueDef\_t}} * \mbox{\hyperlink{structQueueDef__t}{QueueSetMemberHandle\_t}};}
\DoxyCodeLine{64 }
\DoxyCodeLine{65 \textcolor{comment}{/* For internal use only. */}}
\DoxyCodeLine{66 \textcolor{preprocessor}{\#define queueSEND\_TO\_BACK                     ( ( BaseType\_t ) 0 )}}
\DoxyCodeLine{67 \textcolor{preprocessor}{\#define queueSEND\_TO\_FRONT                    ( ( BaseType\_t ) 1 )}}
\DoxyCodeLine{68 \textcolor{preprocessor}{\#define queueOVERWRITE                        ( ( BaseType\_t ) 2 )}}
\DoxyCodeLine{69 }
\DoxyCodeLine{70 \textcolor{comment}{/* For internal use only.  These definitions *must* match those in queue.c. */}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#define queueQUEUE\_TYPE\_BASE                  ( ( uint8\_t ) 0U )}}
\DoxyCodeLine{72 \textcolor{preprocessor}{\#define queueQUEUE\_TYPE\_SET                   ( ( uint8\_t ) 0U )}}
\DoxyCodeLine{73 \textcolor{preprocessor}{\#define queueQUEUE\_TYPE\_MUTEX                 ( ( uint8\_t ) 1U )}}
\DoxyCodeLine{74 \textcolor{preprocessor}{\#define queueQUEUE\_TYPE\_COUNTING\_SEMAPHORE    ( ( uint8\_t ) 2U )}}
\DoxyCodeLine{75 \textcolor{preprocessor}{\#define queueQUEUE\_TYPE\_BINARY\_SEMAPHORE      ( ( uint8\_t ) 3U )}}
\DoxyCodeLine{76 \textcolor{preprocessor}{\#define queueQUEUE\_TYPE\_RECURSIVE\_MUTEX       ( ( uint8\_t ) 4U )}}
\DoxyCodeLine{77 }
\DoxyCodeLine{146 \textcolor{preprocessor}{\#if ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 )}}
\DoxyCodeLine{147 \textcolor{preprocessor}{    \#define xQueueCreate( uxQueueLength, uxItemSize )    xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE\_TYPE\_BASE ) )}}
\DoxyCodeLine{148 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{149 }
\DoxyCodeLine{232 \textcolor{preprocessor}{\#if ( configSUPPORT\_STATIC\_ALLOCATION == 1 )}}
\DoxyCodeLine{233 \textcolor{preprocessor}{    \#define xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer )    xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE\_TYPE\_BASE ) )}}
\DoxyCodeLine{234 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configSUPPORT\_STATIC\_ALLOCATION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{235 }
\DoxyCodeLine{314 \textcolor{preprocessor}{\#define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) \(\backslash\)}}
\DoxyCodeLine{315 \textcolor{preprocessor}{    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND\_TO\_FRONT )}}
\DoxyCodeLine{316 }
\DoxyCodeLine{397 \textcolor{preprocessor}{\#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) \(\backslash\)}}
\DoxyCodeLine{398 \textcolor{preprocessor}{    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND\_TO\_BACK )}}
\DoxyCodeLine{399 }
\DoxyCodeLine{482 \textcolor{preprocessor}{\#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) \(\backslash\)}}
\DoxyCodeLine{483 \textcolor{preprocessor}{    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND\_TO\_BACK )}}
\DoxyCodeLine{484 }
\DoxyCodeLine{566 \textcolor{preprocessor}{\#define xQueueOverwrite( xQueue, pvItemToQueue ) \(\backslash\)}}
\DoxyCodeLine{567 \textcolor{preprocessor}{    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )}}
\DoxyCodeLine{568 }
\DoxyCodeLine{569 }
\DoxyCodeLine{655 BaseType\_t xQueueGenericSend( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{656                               \textcolor{keyword}{const} \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvItemToQueue,}
\DoxyCodeLine{657                               TickType\_t xTicksToWait,}
\DoxyCodeLine{658                               \textcolor{keyword}{const} BaseType\_t xCopyPosition ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{659 }
\DoxyCodeLine{753 BaseType\_t xQueuePeek( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{754                        \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvBuffer,}
\DoxyCodeLine{755                        TickType\_t xTicksToWait ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{756 }
\DoxyCodeLine{789 BaseType\_t xQueuePeekFromISR( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{790                               \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvBuffer ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{791 }
\DoxyCodeLine{882 BaseType\_t xQueueReceive( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{883                           \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvBuffer,}
\DoxyCodeLine{884                           TickType\_t xTicksToWait ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{885 }
\DoxyCodeLine{901 UBaseType\_t uxQueueMessagesWaiting( \textcolor{keyword}{const} \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{902 }
\DoxyCodeLine{920 UBaseType\_t uxQueueSpacesAvailable( \textcolor{keyword}{const} \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{921 }
\DoxyCodeLine{936 \textcolor{keywordtype}{void} vQueueDelete( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{937 }
\DoxyCodeLine{1006 \textcolor{preprocessor}{\#define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) \(\backslash\)}}
\DoxyCodeLine{1007 \textcolor{preprocessor}{    xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND\_TO\_FRONT )}}
\DoxyCodeLine{1008 }
\DoxyCodeLine{1009 }
\DoxyCodeLine{1078 \textcolor{preprocessor}{\#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) \(\backslash\)}}
\DoxyCodeLine{1079 \textcolor{preprocessor}{    xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND\_TO\_BACK )}}
\DoxyCodeLine{1080 }
\DoxyCodeLine{1166 \textcolor{preprocessor}{\#define xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) \(\backslash\)}}
\DoxyCodeLine{1167 \textcolor{preprocessor}{    xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )}}
\DoxyCodeLine{1168 }
\DoxyCodeLine{1241 \textcolor{preprocessor}{\#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) \(\backslash\)}}
\DoxyCodeLine{1242 \textcolor{preprocessor}{    xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND\_TO\_BACK )}}
\DoxyCodeLine{1243 }
\DoxyCodeLine{1321 BaseType\_t xQueueGenericSendFromISR( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{1322                                      \textcolor{keyword}{const} \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvItemToQueue,}
\DoxyCodeLine{1323                                      BaseType\_t * \textcolor{keyword}{const} pxHigherPriorityTaskWoken,}
\DoxyCodeLine{1324                                      \textcolor{keyword}{const} BaseType\_t xCopyPosition ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1325 BaseType\_t xQueueGiveFromISR( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{1326                               BaseType\_t * \textcolor{keyword}{const} pxHigherPriorityTaskWoken ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1327 }
\DoxyCodeLine{1415 BaseType\_t xQueueReceiveFromISR( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{1416                                  \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvBuffer,}
\DoxyCodeLine{1417                                  BaseType\_t * \textcolor{keyword}{const} pxHigherPriorityTaskWoken ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1418 }
\DoxyCodeLine{1419 \textcolor{comment}{/*}}
\DoxyCodeLine{1420 \textcolor{comment}{ * Utilities to query queues that are safe to use from an ISR.  These utilities}}
\DoxyCodeLine{1421 \textcolor{comment}{ * should be used only from witin an ISR, or within a critical section.}}
\DoxyCodeLine{1422 \textcolor{comment}{ */}}
\DoxyCodeLine{1423 BaseType\_t xQueueIsQueueEmptyFromISR( \textcolor{keyword}{const} \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1424 BaseType\_t xQueueIsQueueFullFromISR( \textcolor{keyword}{const} \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1425 UBaseType\_t uxQueueMessagesWaitingFromISR( \textcolor{keyword}{const} \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1426 }
\DoxyCodeLine{1427 \textcolor{comment}{/*}}
\DoxyCodeLine{1428 \textcolor{comment}{ * The functions defined above are for passing data to and from tasks.  The}}
\DoxyCodeLine{1429 \textcolor{comment}{ * functions below are the equivalents for passing data to and from}}
\DoxyCodeLine{1430 \textcolor{comment}{ * co-\/routines.}}
\DoxyCodeLine{1431 \textcolor{comment}{ *}}
\DoxyCodeLine{1432 \textcolor{comment}{ * These functions are called from the co-\/routine macro implementation and}}
\DoxyCodeLine{1433 \textcolor{comment}{ * should not be called directly from application code.  Instead use the macro}}
\DoxyCodeLine{1434 \textcolor{comment}{ * wrappers defined within croutine.h.}}
\DoxyCodeLine{1435 \textcolor{comment}{ */}}
\DoxyCodeLine{1436 BaseType\_t xQueueCRSendFromISR( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{1437                                 \textcolor{keyword}{const} \textcolor{keywordtype}{void} * pvItemToQueue,}
\DoxyCodeLine{1438                                 BaseType\_t xCoRoutinePreviouslyWoken );}
\DoxyCodeLine{1439 BaseType\_t xQueueCRReceiveFromISR( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{1440                                    \textcolor{keywordtype}{void} * pvBuffer,}
\DoxyCodeLine{1441                                    BaseType\_t * pxTaskWoken );}
\DoxyCodeLine{1442 BaseType\_t xQueueCRSend( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{1443                          \textcolor{keyword}{const} \textcolor{keywordtype}{void} * pvItemToQueue,}
\DoxyCodeLine{1444                          TickType\_t xTicksToWait );}
\DoxyCodeLine{1445 BaseType\_t xQueueCRReceive( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{1446                             \textcolor{keywordtype}{void} * pvBuffer,}
\DoxyCodeLine{1447                             TickType\_t xTicksToWait );}
\DoxyCodeLine{1448 }
\DoxyCodeLine{1449 \textcolor{comment}{/*}}
\DoxyCodeLine{1450 \textcolor{comment}{ * For internal use only.  Use xSemaphoreCreateMutex(),}}
\DoxyCodeLine{1451 \textcolor{comment}{ * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling}}
\DoxyCodeLine{1452 \textcolor{comment}{ * these functions directly.}}
\DoxyCodeLine{1453 \textcolor{comment}{ */}}
\DoxyCodeLine{1454 \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueueCreateMutex( \textcolor{keyword}{const} uint8\_t ucQueueType ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1455 \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueueCreateMutexStatic( \textcolor{keyword}{const} uint8\_t ucQueueType,}
\DoxyCodeLine{1456                                        \mbox{\hyperlink{structxSTATIC__QUEUE}{StaticQueue\_t}} * pxStaticQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1457 \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueueCreateCountingSemaphore( \textcolor{keyword}{const} UBaseType\_t uxMaxCount,}
\DoxyCodeLine{1458                                              \textcolor{keyword}{const} UBaseType\_t uxInitialCount ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1459 \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueueCreateCountingSemaphoreStatic( \textcolor{keyword}{const} UBaseType\_t uxMaxCount,}
\DoxyCodeLine{1460                                                    \textcolor{keyword}{const} UBaseType\_t uxInitialCount,}
\DoxyCodeLine{1461                                                    \mbox{\hyperlink{structxSTATIC__QUEUE}{StaticQueue\_t}} * pxStaticQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1462 BaseType\_t xQueueSemaphoreTake( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{1463                                 TickType\_t xTicksToWait ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1464 TaskHandle\_t xQueueGetMutexHolder( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xSemaphore ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1465 TaskHandle\_t xQueueGetMutexHolderFromISR( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xSemaphore ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1466 }
\DoxyCodeLine{1467 \textcolor{comment}{/*}}
\DoxyCodeLine{1468 \textcolor{comment}{ * For internal use only.  Use xSemaphoreTakeMutexRecursive() or}}
\DoxyCodeLine{1469 \textcolor{comment}{ * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.}}
\DoxyCodeLine{1470 \textcolor{comment}{ */}}
\DoxyCodeLine{1471 BaseType\_t xQueueTakeMutexRecursive( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xMutex,}
\DoxyCodeLine{1472                                      TickType\_t xTicksToWait ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1473 BaseType\_t xQueueGiveMutexRecursive( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xMutex ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1474 }
\DoxyCodeLine{1475 \textcolor{comment}{/*}}
\DoxyCodeLine{1476 \textcolor{comment}{ * Reset a queue back to its original empty state.  The return value is now}}
\DoxyCodeLine{1477 \textcolor{comment}{ * obsolete and is always set to pdPASS.}}
\DoxyCodeLine{1478 \textcolor{comment}{ */}}
\DoxyCodeLine{1479 \textcolor{preprocessor}{\#define xQueueReset( xQueue )    xQueueGenericReset( xQueue, pdFALSE )}}
\DoxyCodeLine{1480 }
\DoxyCodeLine{1481 \textcolor{comment}{/*}}
\DoxyCodeLine{1482 \textcolor{comment}{ * The registry is provided as a means for kernel aware debuggers to}}
\DoxyCodeLine{1483 \textcolor{comment}{ * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add}}
\DoxyCodeLine{1484 \textcolor{comment}{ * a queue, semaphore or mutex handle to the registry if you want the handle}}
\DoxyCodeLine{1485 \textcolor{comment}{ * to be available to a kernel aware debugger.  If you are not using a kernel}}
\DoxyCodeLine{1486 \textcolor{comment}{ * aware debugger then this function can be ignored.}}
\DoxyCodeLine{1487 \textcolor{comment}{ *}}
\DoxyCodeLine{1488 \textcolor{comment}{ * configQUEUE\_REGISTRY\_SIZE defines the maximum number of handles the}}
\DoxyCodeLine{1489 \textcolor{comment}{ * registry can hold.  configQUEUE\_REGISTRY\_SIZE must be greater than 0}}
\DoxyCodeLine{1490 \textcolor{comment}{ * within FreeRTOSConfig.h for the registry to be available.  Its value}}
\DoxyCodeLine{1491 \textcolor{comment}{ * does not effect the number of queues, semaphores and mutexes that can be}}
\DoxyCodeLine{1492 \textcolor{comment}{ * created -\/ just the number that the registry can hold.}}
\DoxyCodeLine{1493 \textcolor{comment}{ *}}
\DoxyCodeLine{1494 \textcolor{comment}{ * @param xQueue The handle of the queue being added to the registry.  This}}
\DoxyCodeLine{1495 \textcolor{comment}{ * is the handle returned by a call to xQueueCreate().  Semaphore and mutex}}
\DoxyCodeLine{1496 \textcolor{comment}{ * handles can also be passed in here.}}
\DoxyCodeLine{1497 \textcolor{comment}{ *}}
\DoxyCodeLine{1498 \textcolor{comment}{ * @param pcName The name to be associated with the handle.  This is the}}
\DoxyCodeLine{1499 \textcolor{comment}{ * name that the kernel aware debugger will display.  The queue registry only}}
\DoxyCodeLine{1500 \textcolor{comment}{ * stores a pointer to the string -\/ so the string must be persistent (global or}}
\DoxyCodeLine{1501 \textcolor{comment}{ * preferably in ROM/Flash), not on the stack.}}
\DoxyCodeLine{1502 \textcolor{comment}{ */}}
\DoxyCodeLine{1503 \textcolor{preprocessor}{\#if ( configQUEUE\_REGISTRY\_SIZE > 0 )}}
\DoxyCodeLine{1504     \textcolor{keywordtype}{void} vQueueAddToRegistry( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{1505                               \textcolor{keyword}{const} \textcolor{keywordtype}{char} * pcQueueName ) PRIVILEGED\_FUNCTION; \textcolor{comment}{/*lint !e971 Unqualified char types are allowed for strings and single characters only. */}}
\DoxyCodeLine{1506 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1507 }
\DoxyCodeLine{1508 \textcolor{comment}{/*}}
\DoxyCodeLine{1509 \textcolor{comment}{ * The registry is provided as a means for kernel aware debuggers to}}
\DoxyCodeLine{1510 \textcolor{comment}{ * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add}}
\DoxyCodeLine{1511 \textcolor{comment}{ * a queue, semaphore or mutex handle to the registry if you want the handle}}
\DoxyCodeLine{1512 \textcolor{comment}{ * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to}}
\DoxyCodeLine{1513 \textcolor{comment}{ * remove the queue, semaphore or mutex from the register.  If you are not using}}
\DoxyCodeLine{1514 \textcolor{comment}{ * a kernel aware debugger then this function can be ignored.}}
\DoxyCodeLine{1515 \textcolor{comment}{ *}}
\DoxyCodeLine{1516 \textcolor{comment}{ * @param xQueue The handle of the queue being removed from the registry.}}
\DoxyCodeLine{1517 \textcolor{comment}{ */}}
\DoxyCodeLine{1518 \textcolor{preprocessor}{\#if ( configQUEUE\_REGISTRY\_SIZE > 0 )}}
\DoxyCodeLine{1519     \textcolor{keywordtype}{void} vQueueUnregisterQueue( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1520 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1521 }
\DoxyCodeLine{1522 \textcolor{comment}{/*}}
\DoxyCodeLine{1523 \textcolor{comment}{ * The queue registry is provided as a means for kernel aware debuggers to}}
\DoxyCodeLine{1524 \textcolor{comment}{ * locate queues, semaphores and mutexes.  Call pcQueueGetName() to look}}
\DoxyCodeLine{1525 \textcolor{comment}{ * up and return the name of a queue in the queue registry from the queue's}}
\DoxyCodeLine{1526 \textcolor{comment}{ * handle.}}
\DoxyCodeLine{1527 \textcolor{comment}{ *}}
\DoxyCodeLine{1528 \textcolor{comment}{ * @param xQueue The handle of the queue the name of which will be returned.}}
\DoxyCodeLine{1529 \textcolor{comment}{ * @return If the queue is in the registry then a pointer to the name of the}}
\DoxyCodeLine{1530 \textcolor{comment}{ * queue is returned.  If the queue is not in the registry then NULL is}}
\DoxyCodeLine{1531 \textcolor{comment}{ * returned.}}
\DoxyCodeLine{1532 \textcolor{comment}{ */}}
\DoxyCodeLine{1533 \textcolor{preprocessor}{\#if ( configQUEUE\_REGISTRY\_SIZE > 0 )}}
\DoxyCodeLine{1534     \textcolor{keyword}{const} \textcolor{keywordtype}{char} * pcQueueGetName( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue ) PRIVILEGED\_FUNCTION; \textcolor{comment}{/*lint !e971 Unqualified char types are allowed for strings and single characters only. */}}
\DoxyCodeLine{1535 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1536 }
\DoxyCodeLine{1537 \textcolor{comment}{/*}}
\DoxyCodeLine{1538 \textcolor{comment}{ * Generic version of the function used to create a queue using dynamic memory}}
\DoxyCodeLine{1539 \textcolor{comment}{ * allocation.  This is called by other functions and macros that create other}}
\DoxyCodeLine{1540 \textcolor{comment}{ * RTOS objects that use the queue structure as their base.}}
\DoxyCodeLine{1541 \textcolor{comment}{ */}}
\DoxyCodeLine{1542 \textcolor{preprocessor}{\#if ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 )}}
\DoxyCodeLine{1543     \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueueGenericCreate( \textcolor{keyword}{const} UBaseType\_t uxQueueLength,}
\DoxyCodeLine{1544                                        \textcolor{keyword}{const} UBaseType\_t uxItemSize,}
\DoxyCodeLine{1545                                        \textcolor{keyword}{const} uint8\_t ucQueueType ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1546 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1547 }
\DoxyCodeLine{1548 \textcolor{comment}{/*}}
\DoxyCodeLine{1549 \textcolor{comment}{ * Generic version of the function used to create a queue using dynamic memory}}
\DoxyCodeLine{1550 \textcolor{comment}{ * allocation.  This is called by other functions and macros that create other}}
\DoxyCodeLine{1551 \textcolor{comment}{ * RTOS objects that use the queue structure as their base.}}
\DoxyCodeLine{1552 \textcolor{comment}{ */}}
\DoxyCodeLine{1553 \textcolor{preprocessor}{\#if ( configSUPPORT\_STATIC\_ALLOCATION == 1 )}}
\DoxyCodeLine{1554     \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueueGenericCreateStatic( \textcolor{keyword}{const} UBaseType\_t uxQueueLength,}
\DoxyCodeLine{1555                                              \textcolor{keyword}{const} UBaseType\_t uxItemSize,}
\DoxyCodeLine{1556                                              uint8\_t * pucQueueStorage,}
\DoxyCodeLine{1557                                              \mbox{\hyperlink{structxSTATIC__QUEUE}{StaticQueue\_t}} * pxStaticQueue,}
\DoxyCodeLine{1558                                              \textcolor{keyword}{const} uint8\_t ucQueueType ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1559 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1560 }
\DoxyCodeLine{1561 \textcolor{comment}{/*}}
\DoxyCodeLine{1562 \textcolor{comment}{ * Queue sets provide a mechanism to allow a task to block (pend) on a read}}
\DoxyCodeLine{1563 \textcolor{comment}{ * operation from multiple queues or semaphores simultaneously.}}
\DoxyCodeLine{1564 \textcolor{comment}{ *}}
\DoxyCodeLine{1565 \textcolor{comment}{ * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this}}
\DoxyCodeLine{1566 \textcolor{comment}{ * function.}}
\DoxyCodeLine{1567 \textcolor{comment}{ *}}
\DoxyCodeLine{1568 \textcolor{comment}{ * A queue set must be explicitly created using a call to xQueueCreateSet()}}
\DoxyCodeLine{1569 \textcolor{comment}{ * before it can be used.  Once created, standard FreeRTOS queues and semaphores}}
\DoxyCodeLine{1570 \textcolor{comment}{ * can be added to the set using calls to xQueueAddToSet().}}
\DoxyCodeLine{1571 \textcolor{comment}{ * xQueueSelectFromSet() is then used to determine which, if any, of the queues}}
\DoxyCodeLine{1572 \textcolor{comment}{ * or semaphores contained in the set is in a state where a queue read or}}
\DoxyCodeLine{1573 \textcolor{comment}{ * semaphore take operation would be successful.}}
\DoxyCodeLine{1574 \textcolor{comment}{ *}}
\DoxyCodeLine{1575 \textcolor{comment}{ * Note 1:  See the documentation on https://www.FreeRTOS.org/RTOS-\/queue-\/sets.html}}
\DoxyCodeLine{1576 \textcolor{comment}{ * for reasons why queue sets are very rarely needed in practice as there are}}
\DoxyCodeLine{1577 \textcolor{comment}{ * simpler methods of blocking on multiple objects.}}
\DoxyCodeLine{1578 \textcolor{comment}{ *}}
\DoxyCodeLine{1579 \textcolor{comment}{ * Note 2:  Blocking on a queue set that contains a mutex will not cause the}}
\DoxyCodeLine{1580 \textcolor{comment}{ * mutex holder to inherit the priority of the blocked task.}}
\DoxyCodeLine{1581 \textcolor{comment}{ *}}
\DoxyCodeLine{1582 \textcolor{comment}{ * Note 3:  An additional 4 bytes of RAM is required for each space in a every}}
\DoxyCodeLine{1583 \textcolor{comment}{ * queue added to a queue set.  Therefore counting semaphores that have a high}}
\DoxyCodeLine{1584 \textcolor{comment}{ * maximum count value should not be added to a queue set.}}
\DoxyCodeLine{1585 \textcolor{comment}{ *}}
\DoxyCodeLine{1586 \textcolor{comment}{ * Note 4:  A receive (in the case of a queue) or take (in the case of a}}
\DoxyCodeLine{1587 \textcolor{comment}{ * semaphore) operation must not be performed on a member of a queue set unless}}
\DoxyCodeLine{1588 \textcolor{comment}{ * a call to xQueueSelectFromSet() has first returned a handle to that set member.}}
\DoxyCodeLine{1589 \textcolor{comment}{ *}}
\DoxyCodeLine{1590 \textcolor{comment}{ * @param uxEventQueueLength Queue sets store events that occur on}}
\DoxyCodeLine{1591 \textcolor{comment}{ * the queues and semaphores contained in the set.  uxEventQueueLength specifies}}
\DoxyCodeLine{1592 \textcolor{comment}{ * the maximum number of events that can be queued at once.  To be absolutely}}
\DoxyCodeLine{1593 \textcolor{comment}{ * certain that events are not lost uxEventQueueLength should be set to the}}
\DoxyCodeLine{1594 \textcolor{comment}{ * total sum of the length of the queues added to the set, where binary}}
\DoxyCodeLine{1595 \textcolor{comment}{ * semaphores and mutexes have a length of 1, and counting semaphores have a}}
\DoxyCodeLine{1596 \textcolor{comment}{ * length set by their maximum count value.  Examples:}}
\DoxyCodeLine{1597 \textcolor{comment}{ *  + If a queue set is to hold a queue of length 5, another queue of length 12,}}
\DoxyCodeLine{1598 \textcolor{comment}{ *    and a binary semaphore, then uxEventQueueLength should be set to}}
\DoxyCodeLine{1599 \textcolor{comment}{ *    (5 + 12 + 1), or 18.}}
\DoxyCodeLine{1600 \textcolor{comment}{ *  + If a queue set is to hold three binary semaphores then uxEventQueueLength}}
\DoxyCodeLine{1601 \textcolor{comment}{ *    should be set to (1 + 1 + 1 ), or 3.}}
\DoxyCodeLine{1602 \textcolor{comment}{ *  + If a queue set is to hold a counting semaphore that has a maximum count of}}
\DoxyCodeLine{1603 \textcolor{comment}{ *    5, and a counting semaphore that has a maximum count of 3, then}}
\DoxyCodeLine{1604 \textcolor{comment}{ *    uxEventQueueLength should be set to (5 + 3), or 8.}}
\DoxyCodeLine{1605 \textcolor{comment}{ *}}
\DoxyCodeLine{1606 \textcolor{comment}{ * @return If the queue set is created successfully then a handle to the created}}
\DoxyCodeLine{1607 \textcolor{comment}{ * queue set is returned.  Otherwise NULL is returned.}}
\DoxyCodeLine{1608 \textcolor{comment}{ */}}
\DoxyCodeLine{1609 \mbox{\hyperlink{structQueueDef__t}{QueueSetHandle\_t}} xQueueCreateSet( \textcolor{keyword}{const} UBaseType\_t uxEventQueueLength ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1610 }
\DoxyCodeLine{1611 \textcolor{comment}{/*}}
\DoxyCodeLine{1612 \textcolor{comment}{ * Adds a queue or semaphore to a queue set that was previously created by a}}
\DoxyCodeLine{1613 \textcolor{comment}{ * call to xQueueCreateSet().}}
\DoxyCodeLine{1614 \textcolor{comment}{ *}}
\DoxyCodeLine{1615 \textcolor{comment}{ * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this}}
\DoxyCodeLine{1616 \textcolor{comment}{ * function.}}
\DoxyCodeLine{1617 \textcolor{comment}{ *}}
\DoxyCodeLine{1618 \textcolor{comment}{ * Note 1:  A receive (in the case of a queue) or take (in the case of a}}
\DoxyCodeLine{1619 \textcolor{comment}{ * semaphore) operation must not be performed on a member of a queue set unless}}
\DoxyCodeLine{1620 \textcolor{comment}{ * a call to xQueueSelectFromSet() has first returned a handle to that set member.}}
\DoxyCodeLine{1621 \textcolor{comment}{ *}}
\DoxyCodeLine{1622 \textcolor{comment}{ * @param xQueueOrSemaphore The handle of the queue or semaphore being added to}}
\DoxyCodeLine{1623 \textcolor{comment}{ * the queue set (cast to an QueueSetMemberHandle\_t type).}}
\DoxyCodeLine{1624 \textcolor{comment}{ *}}
\DoxyCodeLine{1625 \textcolor{comment}{ * @param xQueueSet The handle of the queue set to which the queue or semaphore}}
\DoxyCodeLine{1626 \textcolor{comment}{ * is being added.}}
\DoxyCodeLine{1627 \textcolor{comment}{ *}}
\DoxyCodeLine{1628 \textcolor{comment}{ * @return If the queue or semaphore was successfully added to the queue set}}
\DoxyCodeLine{1629 \textcolor{comment}{ * then pdPASS is returned.  If the queue could not be successfully added to the}}
\DoxyCodeLine{1630 \textcolor{comment}{ * queue set because it is already a member of a different queue set then pdFAIL}}
\DoxyCodeLine{1631 \textcolor{comment}{ * is returned.}}
\DoxyCodeLine{1632 \textcolor{comment}{ */}}
\DoxyCodeLine{1633 BaseType\_t xQueueAddToSet( \mbox{\hyperlink{structQueueDef__t}{QueueSetMemberHandle\_t}} xQueueOrSemaphore,}
\DoxyCodeLine{1634                            \mbox{\hyperlink{structQueueDef__t}{QueueSetHandle\_t}} xQueueSet ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1635 }
\DoxyCodeLine{1636 \textcolor{comment}{/*}}
\DoxyCodeLine{1637 \textcolor{comment}{ * Removes a queue or semaphore from a queue set.  A queue or semaphore can only}}
\DoxyCodeLine{1638 \textcolor{comment}{ * be removed from a set if the queue or semaphore is empty.}}
\DoxyCodeLine{1639 \textcolor{comment}{ *}}
\DoxyCodeLine{1640 \textcolor{comment}{ * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this}}
\DoxyCodeLine{1641 \textcolor{comment}{ * function.}}
\DoxyCodeLine{1642 \textcolor{comment}{ *}}
\DoxyCodeLine{1643 \textcolor{comment}{ * @param xQueueOrSemaphore The handle of the queue or semaphore being removed}}
\DoxyCodeLine{1644 \textcolor{comment}{ * from the queue set (cast to an QueueSetMemberHandle\_t type).}}
\DoxyCodeLine{1645 \textcolor{comment}{ *}}
\DoxyCodeLine{1646 \textcolor{comment}{ * @param xQueueSet The handle of the queue set in which the queue or semaphore}}
\DoxyCodeLine{1647 \textcolor{comment}{ * is included.}}
\DoxyCodeLine{1648 \textcolor{comment}{ *}}
\DoxyCodeLine{1649 \textcolor{comment}{ * @return If the queue or semaphore was successfully removed from the queue set}}
\DoxyCodeLine{1650 \textcolor{comment}{ * then pdPASS is returned.  If the queue was not in the queue set, or the}}
\DoxyCodeLine{1651 \textcolor{comment}{ * queue (or semaphore) was not empty, then pdFAIL is returned.}}
\DoxyCodeLine{1652 \textcolor{comment}{ */}}
\DoxyCodeLine{1653 BaseType\_t xQueueRemoveFromSet( \mbox{\hyperlink{structQueueDef__t}{QueueSetMemberHandle\_t}} xQueueOrSemaphore,}
\DoxyCodeLine{1654                                 \mbox{\hyperlink{structQueueDef__t}{QueueSetHandle\_t}} xQueueSet ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1655 }
\DoxyCodeLine{1656 \textcolor{comment}{/*}}
\DoxyCodeLine{1657 \textcolor{comment}{ * xQueueSelectFromSet() selects from the members of a queue set a queue or}}
\DoxyCodeLine{1658 \textcolor{comment}{ * semaphore that either contains data (in the case of a queue) or is available}}
\DoxyCodeLine{1659 \textcolor{comment}{ * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively}}
\DoxyCodeLine{1660 \textcolor{comment}{ * allows a task to block (pend) on a read operation on all the queues and}}
\DoxyCodeLine{1661 \textcolor{comment}{ * semaphores in a queue set simultaneously.}}
\DoxyCodeLine{1662 \textcolor{comment}{ *}}
\DoxyCodeLine{1663 \textcolor{comment}{ * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this}}
\DoxyCodeLine{1664 \textcolor{comment}{ * function.}}
\DoxyCodeLine{1665 \textcolor{comment}{ *}}
\DoxyCodeLine{1666 \textcolor{comment}{ * Note 1:  See the documentation on https://www.FreeRTOS.org/RTOS-\/queue-\/sets.html}}
\DoxyCodeLine{1667 \textcolor{comment}{ * for reasons why queue sets are very rarely needed in practice as there are}}
\DoxyCodeLine{1668 \textcolor{comment}{ * simpler methods of blocking on multiple objects.}}
\DoxyCodeLine{1669 \textcolor{comment}{ *}}
\DoxyCodeLine{1670 \textcolor{comment}{ * Note 2:  Blocking on a queue set that contains a mutex will not cause the}}
\DoxyCodeLine{1671 \textcolor{comment}{ * mutex holder to inherit the priority of the blocked task.}}
\DoxyCodeLine{1672 \textcolor{comment}{ *}}
\DoxyCodeLine{1673 \textcolor{comment}{ * Note 3:  A receive (in the case of a queue) or take (in the case of a}}
\DoxyCodeLine{1674 \textcolor{comment}{ * semaphore) operation must not be performed on a member of a queue set unless}}
\DoxyCodeLine{1675 \textcolor{comment}{ * a call to xQueueSelectFromSet() has first returned a handle to that set member.}}
\DoxyCodeLine{1676 \textcolor{comment}{ *}}
\DoxyCodeLine{1677 \textcolor{comment}{ * @param xQueueSet The queue set on which the task will (potentially) block.}}
\DoxyCodeLine{1678 \textcolor{comment}{ *}}
\DoxyCodeLine{1679 \textcolor{comment}{ * @param xTicksToWait The maximum time, in ticks, that the calling task will}}
\DoxyCodeLine{1680 \textcolor{comment}{ * remain in the Blocked state (with other tasks executing) to wait for a member}}
\DoxyCodeLine{1681 \textcolor{comment}{ * of the queue set to be ready for a successful queue read or semaphore take}}
\DoxyCodeLine{1682 \textcolor{comment}{ * operation.}}
\DoxyCodeLine{1683 \textcolor{comment}{ *}}
\DoxyCodeLine{1684 \textcolor{comment}{ * @return xQueueSelectFromSet() will return the handle of a queue (cast to}}
\DoxyCodeLine{1685 \textcolor{comment}{ * a QueueSetMemberHandle\_t type) contained in the queue set that contains data,}}
\DoxyCodeLine{1686 \textcolor{comment}{ * or the handle of a semaphore (cast to a QueueSetMemberHandle\_t type) contained}}
\DoxyCodeLine{1687 \textcolor{comment}{ * in the queue set that is available, or NULL if no such queue or semaphore}}
\DoxyCodeLine{1688 \textcolor{comment}{ * exists before before the specified block time expires.}}
\DoxyCodeLine{1689 \textcolor{comment}{ */}}
\DoxyCodeLine{1690 \mbox{\hyperlink{structQueueDef__t}{QueueSetMemberHandle\_t}} xQueueSelectFromSet( \mbox{\hyperlink{structQueueDef__t}{QueueSetHandle\_t}} xQueueSet,}
\DoxyCodeLine{1691                                             \textcolor{keyword}{const} TickType\_t xTicksToWait ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1692 }
\DoxyCodeLine{1693 \textcolor{comment}{/*}}
\DoxyCodeLine{1694 \textcolor{comment}{ * A version of xQueueSelectFromSet() that can be used from an ISR.}}
\DoxyCodeLine{1695 \textcolor{comment}{ */}}
\DoxyCodeLine{1696 \mbox{\hyperlink{structQueueDef__t}{QueueSetMemberHandle\_t}} xQueueSelectFromSetFromISR( \mbox{\hyperlink{structQueueDef__t}{QueueSetHandle\_t}} xQueueSet ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1697 }
\DoxyCodeLine{1698 \textcolor{comment}{/* Not public API functions. */}}
\DoxyCodeLine{1699 \textcolor{keywordtype}{void} vQueueWaitForMessageRestricted( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{1700                                      TickType\_t xTicksToWait,}
\DoxyCodeLine{1701                                      \textcolor{keyword}{const} BaseType\_t xWaitIndefinitely ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1702 BaseType\_t xQueueGenericReset( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{1703                                BaseType\_t xNewQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1704 \textcolor{keywordtype}{void} vQueueSetQueueNumber( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue,}
\DoxyCodeLine{1705                            UBaseType\_t uxQueueNumber ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1706 UBaseType\_t uxQueueGetQueueNumber( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1707 uint8\_t ucQueueGetQueueType( \mbox{\hyperlink{structQueueDef__t}{QueueHandle\_t}} xQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{1708 }
\DoxyCodeLine{1709 }
\DoxyCodeLine{1710 \textcolor{comment}{/* *INDENT-\/OFF* */}}
\DoxyCodeLine{1711 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{1712     \}}
\DoxyCodeLine{1713 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1714 \textcolor{comment}{/* *INDENT-\/ON* */}}
\DoxyCodeLine{1715 }
\DoxyCodeLine{1716 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* QUEUE\_H */}\textcolor{preprocessor}{}}

\end{DoxyCode}
